-------------------------------------------------------------------------------------------------------------------------------------------
================================================================ 第 I 部分: 加密 ===========================================================
-------------------------------------------------------------------------------------------------------------------------------------------

第二章:
    密码学的工具箱:
        古典加密, 对称加密, 非对称加密, 数字签名, 消息认证码, 伪随机数生成器

    古典密码学: 移位算法  替换算法 , 凯撒密码[移位算法], Enigma加密机器[替换算法]

第三章: 常用的对称加密算法 DES, AES
    比特序列:
        任何一个段文字甚至字母都可以转化为一个byte[], 这过程叫编码, 而这个byte[] 叫做比特序列

    XOR: 是针对相同长度的比特序列的一种运算
        异或操作运算规则,参考翻硬币   0: 不翻  1:翻
        0 + 0 = 0 -> (不翻) + (不翻) = (不翻)
        0 + 1 = 1 -> (不翻) + (翻) = (翻)
        1 + 0 = 1 -> (翻) + (不翻) = (翻)
        1 + 1 = 0 -> (翻) + (翻) = (不翻)

    Feistel网络:
        Feistel 网络的中的一轮, 每轮之间交换左侧和右侧, 这种模式是DES 加密算法的核心模式! 它的组件包括: 左侧比特序列, 右侧比特序列, 子秘钥, 轮函数f(...), XOR操作

    DES : (64比特为一组)
        (Data Encryption Standard), DES 是一种以64比特为一组的明文加密成64比特密文的对称机密算法! 这种分组的加密算法称之为分组加密算法;

        三重DES(Triple DES)  加密(Encryption) -> 解密(Decryption) -> 加密(Encryption); DES-EDE2, DES-EDE3 分别表示使用 不同子秘钥 的个数

    AES : (128比特为一组) 最好的对称加密算法
        (Advanced Encryption Standard), 以128比特为一组的分组加密算法

第四章: 对称加密   分组加密的模式
    明文分组:
        使用分组密码加密算法对明文进行分组的操作后产生的小组称为明文分组!
    密文分组:
        将明文分组进行加密后得到的密文组称为密文分组!

    ECB : Electronic CodeBook 电子密码模式
    ECB模式弱点 : 主动攻击者不需要知道密文内容, 密文分组, 秘钥 只需对所有分组的顺序进行打乱就可以操作明文


第五章: 非对称加密
    储物柜问题: 投钱关闭, 钥匙开锁 -> 钱币是关闭秘钥, 钥匙是开启秘钥

    秘钥配送问题:  在对称加密通信系统中, 如果A发送了加密消息message到B,
                 B如果不知道解密消息的秘钥则接收到的消息是无法解密的,
                 这就要求A在发送消息时必须把加密消息的秘钥也同时发送给B,
                 这样就造成了秘钥和加密信息同时被拦截的可能性,
                 这种问题就是秘钥传送问题或秘钥配送问题


    秘钥分配中心 解决方案和存在的问题
    过程:
        1、A用户 和 B用户要想通信, 必须先注册一个系统获取自己的秘钥, 分别对应秘钥A和秘钥B
        2、A用户 想和 B用户 通信, A用户向 秘钥分配中心 发出请求
        3、秘钥分配中心 向 A用户 发送秘钥A加密过的 会话秘钥 信息
        4、秘钥分配中心 向 B用户 发送秘钥B加密过的 会话秘钥 信息
        5、A用户用 秘钥A 对来自 秘钥分配中心 的消息进行解密,得到 会话秘钥
        6、A用户用 会话秘钥对 发送给 B用户的 消息进行加密
        7、B用户用 秘钥B 对来自 秘钥分配中心 的消息进行解密,得到 会话秘钥
        8、B用户用 会话秘钥对来自 A用户的 消息进行解密,得到解密信息
        9、A用户 和 B用户 删除会话秘钥
    问题:
        1、秘钥分配中心 压力大
        2、秘钥分配中心 一旦挂掉,加密通信系统瘫痪
        3、秘钥分配中心 一旦被攻克, 整个加密通信系统将毫无秘密可言, 非常危险


    RSA:
        RSA 加密算法 : 密文 = 明文^E mod N; 在这个算法中 密文和明文都是数字, 同样 E,N 也都是数字
        RSA 解密算法 : 明文 = 密文^D mod N; 在这个算法中 密文和明文都是数字, 同样 D,N 也都是数字


第六章: 混合加密系统
    加密过程: 加密 -> 加密 -> 组合 (a.对称加密 -> b.非对称加密 -> c.组合)
    解密过程: 拆分 -> 解密 -> 解密 (a.拆分 -> b.非对称解密 -> c.对称解密)

    伪随机数生成器: 在混合加密系统中, 伪随机数生成器用来生成会话秘钥, 如果生成的会话秘钥特别的简单,会被轻易的破解! 因此在生成会话秘钥的时候要特别的加强,
    但对于非对称加密来说,非对称加密的强度要高过对称加密, 因为一旦非对称加密一旦被破译, 所有的信息就破译了!

-------------------------------------------------------------------------------------------------------------------------------------------
================================================================ 第 II 部分: 认证 ===========================================================
-------------------------------------------------------------------------------------------------------------------------------------------
第七章 数字指纹
        单向散列函数: 有输入有输出的一种函数, 这种函数的输入称为消息, 输出称为散列值! 散列值 又称为 哈希值, 消息摘要, 数字指纹
        单向散列函数的特性: 1、输出固定长度的值    2、运算快速      3、具有抗碰撞性    4、单向性(通过消息计算出散列值非常容易,但通过散列值推算消息几乎是不可能的)

        单向散列函数的用处:
                        1、校验文件是否被篡改  2、基于口令的加密(Password Based Encryption)
                        3、消息认证码(Message Authentication Code)   4、数字签名     5、伪随机数生成器
                        6、一次性口令

        单向散列函数无法解决的问题: 只能验证文件是否为修改过, 但无法辨认出伪装来! 主动攻击者伪装为消息发送者这是验证不出来的!
        数字指纹的破解: 暴力破解(根据文件的冗余性, 破解上限次数为2^哈希值比特位数), 生日攻击

第八章 消息认证码
        为了解决消息指纹的伪装问题, 引入认证相关的知识, 消息认证码, 是在Hash的基础上对消息指纹进行加密
        消息认证码: 单向散列函数的输入值 为消息+共享秘钥, 输出的定长的值就是消息认证码, 不仅可以解决消息的一致性也可以解决伪装的问题!
        HMAC: 使用单向散列函数获取文件散列值的方式, 任何高强度的单向散列函数都可以用来作为HMAC的算法!

        消息认证码不能解决的问题:
            对第三方证明问题, 即无法向第三方证明是 持有共享秘钥的 A方 还是 持有秘钥的B方 向A/B 发送了一条消息! 这也就造成了不具有抗否认的问题!

第九章 数字签名
        Alice 和 Bob 共同持有 生成消息认证码的 共享秘钥
        由于消息认证码无法解决 一条消息是由Alice发送的还是由Bob发送的, 引入数字签名的概念!
        假设 Alice 和 Bob 不共享秘钥, 且发送消息者只能签名, 消息接收者只能验证, 这就解决了一致性, 伪装, 抗否认性等通信中的问题!
        数字签名的使用过程: 生成签名和验证签名, 私钥签名 公钥认证!

        公钥证书: 为保证某个公钥的一致性,为公钥进行签名 对公钥进行数字签名后得到的就是公钥证书

































































